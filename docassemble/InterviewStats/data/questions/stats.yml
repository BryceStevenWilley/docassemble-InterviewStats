---
metadata:
  title: All Interview Statistics
  short title: view stats
  temporary session: True
  required privileges:
    - admin
---
features:
  javascript:
    - https://cdn.bokeh.org/bokeh/release/bokeh-2.2.3.min.js
    - https://cdn.bokeh.org/bokeh/release/bokeh-widgets-2.2.3.min.js
    - https://cdn.bokeh.org/bokeh/release/bokeh-tables-2.2.3.min.js
---
modules:
  - .snapshot_statistics
  - .snapshot_geography
---
objects:
  - xlsx_output: DAFile.using(filename="stats.xlsx")
---
id: interview order
mandatory: True
code: |
  filename
  formatted_data
  saved_data
---
code: |
  log('Logging stats, when outputting')
  for stat in stats:
    log(stat)
  proper_name = space_to_underscore(filename) + "_stats"
  xlsx_output.initialize(filename=proper_name + ".xlsx")
  writer = pd.ExcelWriter(xlsx_output.path(),
    engine='xlsxwriter',
    options={'remove_timezone': True})
  formatted_data.to_excel(writer, index=False)
  writer.save()
  xlsx_output.commit()  
  del writer
  saved_data = True
---
depends on:
  - filter_list
code: |
  if defined('filter_list'):
    geo_layout = make_usage_map(formatted_data, 'zip', filter_list)
  else:
    geo_layout = make_usage_map(formatted_data)
  map_script, map_div, map_inline = get_embedable_usage_map(geo_layout)
  del geo_layout
---
question: |
  What interview do you want to view statistics for?  
fields:
  - Filename: filename
    code: |
      [{interview.get('filename'): interview.get('title')} for interview in interview_menu()]
---
code: |
  interview_title = next(iter([interview.get('title') for interview in interview_menu() if interview.get('filename') == filename]), '(interview)')
  #for interview in interview_menu():
  #  if interview.get('filename') == filename:  
  #    interview_title = interview.get('
---
code: |
  if 'data/questions' in filename:
    stats = get_stats(filename)
  else:
    stats = get_stats(filename.replace(':',':data/questions/'))
  log('Logging stats')
  for stat in stats:
    log(stat)
---
need: stats
code: |
  try:
    first_row = next(iter(stats))
    if first_row and isinstance(first_row, tuple) and isinstance(first_row[1], dict):
      columns = list(first_row[1].keys())
    states = set([row[1]['state'] for row in stats])
  except Exception as ex:
    log('Columns will be blank because of :')
    log(type(ex))
    log(ex.args)
    log(ex)
    columns = ['']
    states = ['']
---
code: |
  import operator
  import pandas as pd
---
code: |
  for stat in stats:
    stat[1]['Modtime'] = stat[0]
  formatted_data = pd.DataFrame([stat[1] for stat in stats])
  log('Logging formatted_data')
  log(formatted_data)
---
mandatory: True
id: view_data
question: |
  Total number of results for ${interview_title}: ${ len(stats) }
subquestion: |
  # TODO(brycew): reformat this Q: show screen with filters first (pre-poped), then show this. Allow user to go back and edit filters
  % if len(stats):
  Group by: 
  % for col in columns:
  [${col}](${ url_action('show_grouped_data', group_by = col ) }) 
  % endfor
  Filter by:
  % for state in states:
  [${state}](${ url_action('filter_data', filter_state = state) })
  % endfor
  
  [:file-excel: Download](${ xlsx_output.url_for() })

  ${ formatted_data.to_html(classes=('table','table-striped'), index=False) }

  ${ map_div }
  % endif
fields:
  - "State to filter on": state_to_filter
  - "Operator to use": chosen_op
script: |
    ${ map_script}
---
event: show_grouped_data
question: |
  Total number of results: ${ len(stats) }
subquestion: |  
  Group by: 
  % for col in columns:
  [${col}](${ url_action('show_grouped_data', group_by = col)  }) 
  % endfor
  
  ${ formatted_data.groupby(by=action_argument('group_by')).count().to_html(classes=('table','table-striped')) }
  
  [:file-excel: Download](${ xlsx_output.url_for() })

  ${ map_div }
script: |
  ${ map_script }

buttons:
  - Restart: restart  
---
event: filter_data
code: |
  import operator
  action_dict = action_arguments()
  arg = action_dict['filter_state']
  op = action_dict.pop('chosen_op', 'eq')
  if op == 'eq':
    filter_list = [('state', operator.eq, arg)]
  elif op == 'ne':
    filter_list = [('state', operator.ne, arg)]
  else:
    filter_list = [('state', lambda x,y: False, arg)]